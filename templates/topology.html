<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®¡ç½‘æ‹“æ‰‘å›¾ - LeakAgent</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- D3.js for network visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Google Fonts (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #171717;
        }

        .network-svg {
            background: #1f2937;
            border-radius: 8px;
        }

        .node {
            cursor: pointer;
            stroke-width: 2;
        }

        .node.junction {
            fill: #3b82f6;
            stroke: #1d4ed8;
        }

        .node.reservoir {
            fill: #10b981;
            stroke: #047857;
        }

        .node.tank {
            fill: #f59e0b;
            stroke: #d97706;
        }

        .link {
            cursor: pointer;
        }

        .link.pipe {
            stroke: #6b7280;
        }

        .link.pump {
            stroke: #ef4444;
        }

        .link.valve {
            stroke: #8b5cf6;
        }

        .node:hover, .link:hover {
            filter: brightness(1.2);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
        }

        .file-item {
            transition: all 0.2s ease;
        }

        .file-item:hover {
            background-color: #374151;
        }

        .file-item.selected {
            background-color: #1d4ed8;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #171717;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4A4A4A;
            border-radius: 4px;
            border: 2px solid #171717;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6c6c6c;
        }
    </style>
</head>
<body class="text-gray-200">
    <!-- Top Navigation Bar -->
    <nav class="bg-gray-800 border-b border-white/10 px-4 py-3">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-6">
                <h1 class="text-xl font-semibold text-white">LeakAgentä¾›æ°´ç®¡ç½‘å‚åŸŸå¤§æ¨¡å‹</h1>
                <div class="flex space-x-4">
                    <a href="/" class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700 transition-colors">
                        ğŸ’¬ æ™ºèƒ½å¯¹è¯
                    </a>
                    <a href="/topology" class="px-3 py-2 rounded-md text-sm font-medium text-white bg-gray-700 hover:bg-gray-600 transition-colors">
                        ğŸ—ºï¸æ‹“æ‰‘å›¾
                    </a>
                </div>
            </div>
            <div class="text-sm text-gray-400">
                ç®¡ç½‘æ‹“æ‰‘ç»“æ„å¯è§†åŒ–ä¸æ•°æ®åˆ†æ
            </div>
        </div>
    </nav>

    <div class="flex h-[calc(100vh-60px)]">
        <!-- Left Sidebar -->
        <aside class="w-80 bg-gray-900 border-r border-white/10 flex flex-col">
            <!-- File Selection -->
            <div class="p-4 border-b border-white/10">
                <h2 class="text-lg font-semibold mb-4">ğŸ“ æ–‡ä»¶é€‰æ‹©</h2>
                
                <!-- INP Files -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-400 mb-2">ç®¡ç½‘æ–‡ä»¶ (.inp)</h3>
                    <div id="inp-files-list" class="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">
                        <div class="text-center text-gray-500 py-4">
                            <div class="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full mx-auto mb-2"></div>
                            åŠ è½½ä¸­...
                        </div>
                    </div>
                </div>

                <!-- CSV Files -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-400 mb-2">æ•°æ®æ–‡ä»¶ (.csv)</h3>
                    <div id="csv-files-list" class="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">
                        <div class="text-center text-gray-500 py-4">
                            è¯·å…ˆé€‰æ‹©ç®¡ç½‘æ–‡ä»¶
                        </div>
                    </div>
                </div>

                <!-- Load Button -->
                <button id="load-topology-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    ğŸ—ºï¸ åŠ è½½æ‹“æ‰‘å›¾
                </button>
            </div>

            <!-- Network Info -->
            <div class="p-4 border-b border-white/10">
                <h3 class="text-sm font-medium text-gray-400 mb-2">ğŸ“Š ç½‘ç»œä¿¡æ¯</h3>
                <div id="network-info" class="text-sm text-gray-300 space-y-1">
                    <div>è¯·é€‰æ‹©ç®¡ç½‘æ–‡ä»¶</div>
                </div>
            </div>


        </aside>

        <!-- Main Content -->
        <main class="flex-1 flex flex-col relative">
            <!-- Toolbar -->
            <div class="bg-gray-800 border-b border-white/10 px-4 py-3">
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center space-x-4">
                        <h2 class="text-lg font-semibold">ç®¡ç½‘æ‹“æ‰‘å›¾</h2>
                        <div id="current-file-info" class="text-sm text-gray-400">
                            æœªé€‰æ‹©æ–‡ä»¶
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="zoom-in-btn" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            ğŸ”+
                        </button>
                        <button id="zoom-out-btn" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            ğŸ”-
                        </button>
                        <button id="reset-view-btn" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            ğŸ¯ é‡ç½®è§†å›¾
                        </button>
                        <button id="legend-toggle" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            ğŸ¨ å›¾ä¾‹
                        </button>
                    </div>
                </div>

                <!-- æ§åˆ¶é¢æ¿ -->
                <div class="flex items-center justify-between space-x-6">
                    <!-- æ—¶é—´æ§åˆ¶ -->
                    <div id="time-controls" class="flex items-center space-x-3" style="display: none;">
                        <span class="text-sm text-gray-400">æ—¶é—´:</span>
                        <input type="range" id="time-slider" min="0" max="24" step="1" value="0"
                               class="w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <span id="time-display" class="text-sm text-white min-w-[60px]">0.0 å°æ—¶</span>
                    </div>

                    <!-- å¤§å°æ§åˆ¶ -->
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-400">èŠ‚ç‚¹:</span>
                            <input type="range" id="node-size-slider" min="0.0" max="3" step="0.1" value="1"
                                   class="w-20 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-400">ç®¡æ®µ:</span>
                            <input type="range" id="link-size-slider" min="0.0" max="3" step="0.1" value="1"
                                   class="w-20 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <!-- IDæ˜¾ç¤ºæ§åˆ¶ -->
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="show-node-ids" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                            <label for="show-node-ids" class="text-sm text-gray-400">èŠ‚ç‚¹ID</label>
                        </div>
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="show-link-ids" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                            <label for="show-link-ids" class="text-sm text-gray-400">ç®¡æ®µID</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Visualization Area -->
            <div class="flex-1 p-4">
                <div id="topology-container" class="w-full h-full bg-gray-800 rounded-lg border border-white/10 relative">
                    <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center">
                        <div class="text-center">
                            <div class="text-6xl mb-4">ğŸ—ºï¸</div>
                            <div class="text-xl text-gray-400">é€‰æ‹©ç®¡ç½‘æ–‡ä»¶å¼€å§‹å¯è§†åŒ–</div>
                            <div class="text-sm text-gray-500 mt-2">æ”¯æŒ EPANET .inp æ ¼å¼æ–‡ä»¶</div>
                        </div>
                    </div>
                    <!-- Floating Legend -->
                    <div id="legend-panel" class="absolute top-4 right-4 z-10 bg-gray-800/95 backdrop-blur-sm border border-white/20 rounded-lg p-3 shadow-lg min-w-[180px]" style="display: none;">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-medium text-gray-300">ğŸ¨ å›¾ä¾‹</h3>
                            <button id="legend-close" class="text-gray-400 hover:text-white text-lg leading-none">&times;</button>
                        </div>
                        <div class="space-y-3 text-xs">
                            <!-- èŠ‚ç‚¹ç±»å‹ -->
                            <div class="space-y-1">
                                <div class="text-xs text-gray-400 font-medium">èŠ‚ç‚¹ç±»å‹</div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-blue-500"></div>
                                    <span class="text-gray-300">æ¥ç‚¹</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-green-500"></div>
                                    <span class="text-gray-300">æ°´åº“</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-yellow-500"></div>
                                    <span class="text-gray-300">æ°´å¡”</span>
                                </div>
                            </div>

                            <!-- ç®¡æ®µç±»å‹ -->
                            <div class="space-y-1">
                                <div class="text-xs text-gray-400 font-medium">ç®¡æ®µç±»å‹</div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-0.5 bg-gray-500"></div>
                                    <span class="text-gray-300">ç®¡é“</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-1 bg-red-500"></div>
                                    <span class="text-gray-300">æ°´æ³µ</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-1 bg-purple-500"></div>
                                    <span class="text-gray-300">é˜€é—¨</span>
                                </div>
                            </div>

                            <!-- æ•°æ®é¢œè‰²è¯´æ˜ -->
                            <div id="data-legend" class="space-y-1" style="display: none;">
                                <div class="text-xs text-gray-400 font-medium">æ•°æ®é¢œè‰²</div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-blue-400"></div>
                                    <span class="text-gray-300">ä½å‹åŠ›</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-red-400"></div>
                                    <span class="text-gray-300">é«˜å‹åŠ›</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-0.5 bg-green-400"></div>
                                    <span class="text-gray-300">æ­£æµé‡</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-0.5 bg-red-400"></div>
                                    <span class="text-gray-300">è´Ÿæµé‡</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <svg id="network-svg" class="w-full h-full network-svg" style="display: none;"></svg>
                </div>
            </div>
        </main>
    </div>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <script>
        // Global variables
        let currentInpFile = null;
        let currentCsvFile = null;
        let networkData = null;
        let csvData = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let currentTimeStep = 0;
        let nodeElements = null;
        let linkElements = null;
        let nodeLabels = null;
        let linkLabels = null;
        let nodeSizeScale = 1;
        let linkSizeScale = 1;
        let showNodeIds = false;
        let showLinkIds = false;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadInpFiles();
            loadCsvFiles();
            initializeVisualization();
        });

        // Load INP files
        async function loadInpFiles() {
            try {
                const response = await fetch('/api/inp_files');
                const data = await response.json();
                
                const container = document.getElementById('inp-files-list');
                
                if (data.success && data.files.length > 0) {
                    container.innerHTML = '';
                    data.files.forEach(file => {
                        const fileItem = createFileItem(file, 'inp');
                        container.appendChild(fileItem);
                    });
                } else {
                    container.innerHTML = '<div class="text-center text-gray-500 py-4">æš‚æ— ç®¡ç½‘æ–‡ä»¶</div>';
                }
            } catch (error) {
                console.error('åŠ è½½INPæ–‡ä»¶å¤±è´¥:', error);
                document.getElementById('inp-files-list').innerHTML = '<div class="text-center text-red-500 py-4">åŠ è½½å¤±è´¥</div>';
            }
        }

        // Load CSV files
        async function loadCsvFiles() {
            try {
                const response = await fetch('/api/csv_files');
                const data = await response.json();
                
                const container = document.getElementById('csv-files-list');
                
                if (data.success && data.files.length > 0) {
                    container.innerHTML = '';
                    data.files.forEach(file => {
                        const fileItem = createFileItem(file, 'csv');
                        container.appendChild(fileItem);
                    });
                } else {
                    container.innerHTML = '<div class="text-center text-gray-500 py-4">æš‚æ— æ•°æ®æ–‡ä»¶</div>';
                }
            } catch (error) {
                console.error('åŠ è½½CSVæ–‡ä»¶å¤±è´¥:', error);
                document.getElementById('csv-files-list').innerHTML = '<div class="text-center text-red-500 py-4">åŠ è½½å¤±è´¥</div>';
            }
        }

        // Create file item element
        function createFileItem(file, type) {
            const div = document.createElement('div');
            div.className = 'file-item p-3 rounded-lg border border-gray-700 cursor-pointer';
            div.dataset.filePath = file.path;
            div.dataset.fileType = type;

            const icon = type === 'inp' ? 'ğŸ“„' : 'ğŸ“Š';
            const size = (file.size / 1024).toFixed(1) + ' KB';
            const date = new Date(file.modified).toLocaleDateString('zh-CN');

            // æ·»åŠ æ–‡ä»¶æ¥æºæ ‡è¯†
            let sourceIcon = '';
            let sourceText = '';
            if (type === 'inp' && file.source) {
                if (file.source === 'uploaded') {
                    sourceIcon = 'ğŸ“¤';
                    sourceText = 'å·²ä¸Šä¼ ';
                } else if (file.source === 'example') {
                    sourceIcon = 'ğŸ“‹';
                    sourceText = 'ç¤ºä¾‹';
                }
            }

            div.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center space-x-2">
                            <span class="text-lg">${icon}</span>
                            <span class="text-sm font-medium truncate">${file.filename}</span>
                            ${sourceIcon ? `<span class="text-xs px-1.5 py-0.5 bg-gray-600 rounded text-gray-300">${sourceIcon} ${sourceText}</span>` : ''}
                        </div>
                        <div class="text-xs text-gray-400 mt-1">
                            ${size} â€¢ ${date}
                        </div>
                    </div>
                </div>
            `;

            // æ·»åŠ å•å‡»å’ŒåŒå‡»äº‹ä»¶å¤„ç†
            let clickTimeout;
            div.addEventListener('click', (e) => {
                clearTimeout(clickTimeout);
                clickTimeout = setTimeout(() => {
                    selectFile(file, type, div);
                }, 250); // 250mså»¶è¿ŸåŒºåˆ†å•å‡»å’ŒåŒå‡»
            });

            div.addEventListener('dblclick', (e) => {
                clearTimeout(clickTimeout);
                deselectFile(type, div);
            });

            return div;
        }

        // Select file
        function selectFile(file, type, element) {
            if (type === 'inp') {
                // Clear previous selection
                document.querySelectorAll('#inp-files-list .file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                element.classList.add('selected');
                currentInpFile = file;

                // Update network info
                updateNetworkInfo();

                // Enable load button if both files selected
                updateLoadButton();
            } else if (type === 'csv') {
                // Clear previous selection
                document.querySelectorAll('#csv-files-list .file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                element.classList.add('selected');
                currentCsvFile = file;

                // Enable load button if both files selected
                updateLoadButton();
            }
        }

        // Deselect file (åŒå‡»å–æ¶ˆé€‰æ‹©)
        function deselectFile(type, element) {
            if (type === 'inp') {
                element.classList.remove('selected');
                currentInpFile = null;
                networkData = null; // æ¸…é™¤ç½‘ç»œæ•°æ®ç¼“å­˜

                // Clear network info
                document.getElementById('network-info').innerHTML = '<div>è¯·é€‰æ‹©ç®¡ç½‘æ–‡ä»¶</div>';

                // Clear topology if loaded
                if (document.getElementById('topology-svg')) {
                    document.getElementById('topology-container').innerHTML = `
                        <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center">
                            <div class="text-center">
                                <div class="text-6xl mb-4">ğŸ—ºï¸</div>
                                <div class="text-xl text-gray-400">é€‰æ‹©ç®¡ç½‘æ–‡ä»¶å¼€å§‹å¯è§†åŒ–</div>
                                <div class="text-sm text-gray-500 mt-2">æ”¯æŒ EPANET .inp æ ¼å¼æ–‡ä»¶</div>
                            </div>
                        </div>
                    `;
                }

                // Update load button
                updateLoadButton();
            } else if (type === 'csv') {
                element.classList.remove('selected');
                currentCsvFile = null;
                csvData = null;

                // Hide time controls
                document.getElementById('time-controls').style.display = 'none';

                // Hide data legend
                document.getElementById('data-legend').style.display = 'none';

                // Reset visualization to show only topology colors
                if (nodeElements && linkElements) {
                    resetVisualizationColors();
                }

                // Update load button
                updateLoadButton();
            }
        }

        // Ensure network data is loaded
        async function ensureNetworkDataLoaded() {
            if (!currentInpFile) {
                throw new Error('æ²¡æœ‰é€‰æ‹©INPæ–‡ä»¶');
            }

            if (networkData) {
                console.log('ç½‘ç»œæ•°æ®å·²å­˜åœ¨ï¼Œè·³è¿‡åŠ è½½');
                return networkData;
            }

            console.log('æ­£åœ¨åŠ è½½ç½‘ç»œæ•°æ®...');
            const response = await fetch(`/api/network_topology/${encodeURIComponent(currentInpFile.path)}`);
            const data = await response.json();

            if (data.success) {
                networkData = data.topology;
                console.log('ç½‘ç»œæ•°æ®åŠ è½½æˆåŠŸ:', {
                    nodes: networkData.nodes.total,
                    links: networkData.links.total
                });

                // åŒæ—¶æ›´æ–°ç½‘ç»œä¿¡æ¯æ˜¾ç¤º
                updateNetworkInfoDisplay();

                return networkData;
            } else {
                throw new Error(data.error || 'åŠ è½½ç½‘ç»œæ•°æ®å¤±è´¥');
            }
        }

        // Update network info display
        function updateNetworkInfoDisplay() {
            if (!networkData) return;

            const infoContainer = document.getElementById('network-info');
            infoContainer.innerHTML = `
                <div>èŠ‚ç‚¹æ€»æ•°: ${networkData.nodes.total}</div>
                <div>â€¢ æ¥ç‚¹: ${networkData.nodes.junctions}</div>
                <div>â€¢ æ°´åº“: ${networkData.nodes.reservoirs}</div>
                <div>â€¢ æ°´å¡”: ${networkData.nodes.tanks}</div>
                <div class="mt-2">ç®¡æ®µæ€»æ•°: ${networkData.links.total}</div>
                <div>â€¢ ç®¡é“: ${networkData.links.pipes}</div>
                <div>â€¢ æ°´æ³µ: ${networkData.links.pumps}</div>
                <div>â€¢ é˜€é—¨: ${networkData.links.valves}</div>
                <div class="mt-2">æ€»é•¿åº¦: ${networkData.network_stats && networkData.network_stats.total_length ? networkData.network_stats.total_length.toFixed(2) : 'N/A'} m</div>
            `;
        }

        // Update network info (legacy function for file selection)
        async function updateNetworkInfo() {
            if (!currentInpFile) return;

            const infoContainer = document.getElementById('network-info');
            infoContainer.innerHTML = '<div class="animate-pulse">åŠ è½½ç½‘ç»œä¿¡æ¯...</div>';

            try {
                await ensureNetworkDataLoaded();
            } catch (error) {
                console.error('è·å–ç½‘ç»œä¿¡æ¯å¤±è´¥:', error);
                infoContainer.innerHTML = '<div class="text-red-400">åŠ è½½å¤±è´¥</div>';
            }
        }

        // Update load button state
        function updateLoadButton() {
            const loadBtn = document.getElementById('load-topology-btn');
            loadBtn.disabled = !currentInpFile;
            
            if (currentInpFile) {
                loadBtn.textContent = currentCsvFile ? 'ğŸ—ºï¸ åŠ è½½æ‹“æ‰‘å›¾ (å«æ•°æ®)' : 'ğŸ—ºï¸ åŠ è½½æ‹“æ‰‘å›¾';
            } else {
                loadBtn.textContent = 'ğŸ—ºï¸ åŠ è½½æ‹“æ‰‘å›¾';
            }
        }

        // Initialize visualization
        function initializeVisualization() {
            svg = d3.select('#network-svg');
            g = svg.append('g');
            
            // Setup zoom
            zoom = d3.zoom()
                .scaleExtent([0.001, 200])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // Zoom controls
            document.getElementById('zoom-in-btn').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1.5);
            });
            
            document.getElementById('zoom-out-btn').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            });
            
            document.getElementById('reset-view-btn').addEventListener('click', () => {
                resetViewToCenter();
            });
            
            // Load topology button
            document.getElementById('load-topology-btn').addEventListener('click', loadTopology);

            // Time slider
            document.getElementById('time-slider').addEventListener('input', (e) => {
                currentTimeStep = parseFloat(e.target.value);
                document.getElementById('time-display').textContent = `${currentTimeStep.toFixed(1)} å°æ—¶`;
                updateVisualizationData();
                // ç¡®ä¿å¤§å°è®¾ç½®ä¸è¢«è¦†ç›–
                updateNodeSizes();
                updateLinkSizes();
            });

            // Size sliders
            document.getElementById('node-size-slider').addEventListener('input', (e) => {
                nodeSizeScale = parseFloat(e.target.value);
                updateNodeSizes();
            });

            document.getElementById('link-size-slider').addEventListener('input', (e) => {
                linkSizeScale = parseFloat(e.target.value);
                updateLinkSizes();
            });

            // ID display toggles
            document.getElementById('show-node-ids').addEventListener('change', (e) => {
                showNodeIds = e.target.checked;
                updateNodeLabelsVisibility();
            });

            document.getElementById('show-link-ids').addEventListener('change', (e) => {
                showLinkIds = e.target.checked;
                updateLinkLabelsVisibility();
            });

            // Legend controls
            document.getElementById('legend-toggle').addEventListener('click', () => {
                const legendPanel = document.getElementById('legend-panel');
                if (legendPanel.style.display === 'none') {
                    legendPanel.style.display = 'block';
                } else {
                    legendPanel.style.display = 'none';
                }
            });

            document.getElementById('legend-close').addEventListener('click', () => {
                document.getElementById('legend-panel').style.display = 'none';
            });
        }

        // Load topology
        async function loadTopology() {
            if (!currentInpFile) return;

            const loadingIndicator = document.getElementById('loading-indicator');
            const networkSvg = document.getElementById('network-svg');

            loadingIndicator.innerHTML = `
                <div class="text-center">
                    <div class="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <div class="text-xl text-gray-400">æ­£åœ¨åŠ è½½ç½‘ç»œæ•°æ®...</div>
                </div>
            `;

            try {
                // ç¡®ä¿ç½‘ç»œæ•°æ®å·²åŠ è½½
                if (!networkData) {
                    console.log('ç½‘ç»œæ•°æ®æœªåŠ è½½ï¼Œæ­£åœ¨è·å–...');
                    await ensureNetworkDataLoaded();
                }

                // æ›´æ–°åŠ è½½çŠ¶æ€
                loadingIndicator.innerHTML = `
                    <div class="text-center">
                        <div class="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                        <div class="text-xl text-gray-400">æ­£åœ¨ç”Ÿæˆæ‹“æ‰‘å›¾...</div>
                    </div>
                `;

                // Load CSV data if selected
                if (currentCsvFile) {
                    await loadCsvData();
                }

                // Generate topology visualization
                await generateTopology();

                // Update visualization with current data
                updateVisualizationData();

                // Apply initial size settings
                updateNodeSizes();
                updateLinkSizes();

                // Hide loading, show SVG
                loadingIndicator.style.display = 'none';
                networkSvg.style.display = 'block';

                // Update current file info
                document.getElementById('current-file-info').textContent =
                    `${currentInpFile.filename}${currentCsvFile ? ' + ' + currentCsvFile.filename : ''}`;

            } catch (error) {
                console.error('åŠ è½½æ‹“æ‰‘å›¾å¤±è´¥:', error);
                loadingIndicator.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4 text-red-500">âŒ</div>
                        <div class="text-xl text-red-400">åŠ è½½å¤±è´¥</div>
                        <div class="text-sm text-gray-500 mt-2">${error.message}</div>
                    </div>
                `;
            }
        }

        // Load CSV data
        async function loadCsvData() {
            if (!currentCsvFile) {
                csvData = null;
                return;
            }

            try {
                const response = await fetch(`/api/csv_data/${encodeURIComponent(currentCsvFile.path)}`);
                const data = await response.json();

                if (data.success) {
                    csvData = data.csv_data;

                    // è®¾ç½®æ—¶é—´æ»‘æ¡èŒƒå›´
                    const timeSlider = document.getElementById('time-slider');
                    const timeSteps = csvData.time_steps || Object.keys(csvData.data_by_time || {}).map(t => parseFloat(t)).sort((a, b) => a - b);
                    if (timeSteps && timeSteps.length > 0) {
                        timeSlider.min = timeSteps[0];
                        timeSlider.max = timeSteps[timeSteps.length - 1];
                        timeSlider.value = timeSteps[0];
                        currentTimeStep = timeSteps[0];

                        // è®¾ç½®æ­¥é•¿ä¸ºæ—¶é—´æ­¥ä¹‹é—´çš„æœ€å°é—´éš”
                        if (timeSteps.length > 1) {
                            const minStep = Math.min(...timeSteps.slice(1).map((t, i) => t - timeSteps[i]));
                            timeSlider.step = minStep;
                        }

                        document.getElementById('time-display').textContent = `${currentTimeStep.toFixed(1)} å°æ—¶`;
                    }

                    // æ˜¾ç¤ºæ—¶é—´æ§åˆ¶
                    document.getElementById('time-controls').style.display = 'flex';

                    // æ˜¾ç¤ºæ•°æ®é¢œè‰²å›¾ä¾‹
                    document.getElementById('data-legend').style.display = 'block';

                    // è‡ªåŠ¨æ˜¾ç¤ºå›¾ä¾‹é¢æ¿
                    document.getElementById('legend-panel').style.display = 'block';

                    // ç«‹å³æ›´æ–°å¯è§†åŒ–æ•°æ®
                    updateVisualizationData();

                    console.log('CSVæ•°æ®åŠ è½½æˆåŠŸ:', csvData.summary);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                console.error('åŠ è½½CSVæ•°æ®å¤±è´¥:', error);
                csvData = null;
                document.getElementById('time-controls').style.display = 'none';
            }
        }

        // Generate topology visualization
        async function generateTopology() {
            // Clear previous visualization
            g.selectAll('*').remove();

            if (!networkData || !networkData.topology) {
                throw new Error('ç½‘ç»œæ‹“æ‰‘æ•°æ®ä¸å¯ç”¨');
            }

            const nodes = networkData.topology.nodes;
            const links = networkData.topology.links;

            if (nodes.length === 0) {
                throw new Error('ç½‘ç»œä¸­æ²¡æœ‰èŠ‚ç‚¹æ•°æ®');
            }

            // è®¡ç®—åæ ‡èŒƒå›´
            const xCoords = nodes.map(n => n.coordinates[0]).filter(x => x !== undefined && x !== null);
            const yCoords = nodes.map(n => n.coordinates[1]).filter(y => y !== undefined && y !== null);

            let xMin = Math.min(...xCoords);
            let xMax = Math.max(...xCoords);
            let yMin = Math.min(...yCoords);
            let yMax = Math.max(...yCoords);

            // å¦‚æœæ²¡æœ‰æœ‰æ•ˆåæ ‡ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´
            if (!isFinite(xMin) || !isFinite(xMax) || !isFinite(yMin) || !isFinite(yMax)) {
                xMin = 0; xMax = 1000; yMin = 0; yMax = 1000;
            }

            // æ·»åŠ è¾¹è·
            const margin = Math.max((xMax - xMin), (yMax - yMin)) * 0.1;
            xMin -= margin; xMax += margin;
            yMin -= margin; yMax += margin;

            // è·å–SVGå°ºå¯¸
            const svgRect = svg.node().getBoundingClientRect();
            const svgWidth = svgRect.width;
            const svgHeight = svgRect.height;

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const scaleX = svgWidth / (xMax - xMin);
            const scaleY = svgHeight / (yMax - yMin);
            const scale = Math.min(scaleX, scaleY) * 0.9; // ç•™ä¸€äº›è¾¹è·

            // å‡†å¤‡æ•°æ®
            const nodeData = nodes.map(node => {
                let x = node.coordinates[0];
                let y = node.coordinates[1];

                // å¦‚æœæ²¡æœ‰åæ ‡ï¼Œéšæœºåˆ†é…
                if (x === undefined || x === null || y === undefined || y === null) {
                    x = xMin + Math.random() * (xMax - xMin);
                    y = yMin + Math.random() * (yMax - yMin);
                }

                // è½¬æ¢åæ ‡ç³»ï¼ˆYè½´ç¿»è½¬ï¼Œå› ä¸ºSVGçš„Yè½´å‘ä¸‹ï¼‰
                const transformedX = (x - xMin) * scale;
                const transformedY = svgHeight - (y - yMin) * scale;

                return {
                    id: node.id,
                    type: node.type,
                    x: transformedX,
                    y: transformedY,
                    originalX: x,
                    originalY: y,
                    elevation: node.elevation || 0,
                    base_demand: node.base_demand || 0,
                    head: node.head || 0,
                    ...node
                };
            });

            const linkData = links.map(link => ({
                source: link.start_node,
                target: link.end_node,
                id: link.id,
                type: link.type,
                length: link.length || 0,
                diameter: link.diameter || 0,
                ...link
            }));

            // åˆ›å»ºèŠ‚ç‚¹IDåˆ°æ•°æ®çš„æ˜ å°„
            const nodeMap = new Map();
            nodeData.forEach(node => nodeMap.set(node.id, node));

            // åˆ›å»ºç®¡æ®µ
            const linkGroup = g.append('g').attr('class', 'links');
            linkElements = linkGroup.selectAll('line')
                .data(linkData)
                .enter().append('line')
                .attr('class', d => `link ${d.type}`)
                .attr('stroke-width', d => {
                    const baseWidth = d.type === 'pump' ? 4 : d.type === 'valve' ? 3 : Math.max(1, Math.min(8, (d.diameter || 100) / 50));
                    return baseWidth * linkSizeScale;
                })
                .attr('x1', d => {
                    const sourceNode = nodeMap.get(d.source);
                    return sourceNode ? sourceNode.x : 0;
                })
                .attr('y1', d => {
                    const sourceNode = nodeMap.get(d.source);
                    return sourceNode ? sourceNode.y : 0;
                })
                .attr('x2', d => {
                    const targetNode = nodeMap.get(d.target);
                    return targetNode ? targetNode.x : 0;
                })
                .attr('y2', d => {
                    const targetNode = nodeMap.get(d.target);
                    return targetNode ? targetNode.y : 0;
                })
                .on('mouseover', showLinkTooltip)
                .on('mouseout', hideTooltip)
                .on('click', showLinkDetails);

            // åˆ›å»ºèŠ‚ç‚¹
            nodeElements = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodeData)
                .enter().append('circle')
                .attr('class', d => `node ${d.type}`)
                .attr('r', d => {
                    const baseRadius = d.type === 'reservoir' ? 12 : d.type === 'tank' ? 10 : 6;
                    return baseRadius * nodeSizeScale;
                })
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .on('mouseover', showNodeTooltip)
                .on('mouseout', hideTooltip)
                .on('click', showNodeDetails);

            // æ·»åŠ èŠ‚ç‚¹æ ‡ç­¾
            nodeLabels = g.append('g')
                .attr('class', 'node-labels')
                .selectAll('text')
                .data(nodeData)
                .enter().append('text')
                .attr('x', d => d.x + 12)
                .attr('y', d => d.y + 4)
                .attr('font-size', '10px')
                .attr('fill', '#9ca3af')
                .style('display', 'none') // é»˜è®¤éšè—
                .text(d => d.id);

            // æ·»åŠ ç®¡æ®µæ ‡ç­¾
            linkLabels = g.append('g')
                .attr('class', 'link-labels')
                .selectAll('text')
                .data(linkData)
                .enter().append('text')
                .attr('x', d => {
                    const sourceNode = nodeMap.get(d.source);
                    const targetNode = nodeMap.get(d.target);
                    return sourceNode && targetNode ? (sourceNode.x + targetNode.x) / 2 : 0;
                })
                .attr('y', d => {
                    const sourceNode = nodeMap.get(d.source);
                    const targetNode = nodeMap.get(d.target);
                    return sourceNode && targetNode ? (sourceNode.y + targetNode.y) / 2 : 0;
                })
                .attr('font-size', '9px')
                .attr('fill', '#6b7280')
                .attr('text-anchor', 'middle')
                .style('display', 'none') // é»˜è®¤éšè—
                .text(d => d.id);

            // è‡ªåŠ¨ç¼©æ”¾åˆ°åˆé€‚çš„è§†å›¾
            const bounds = g.node().getBBox();
            const fullWidth = svgWidth;
            const fullHeight = svgHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width == 0 || height == 0) return; // æ²¡æœ‰å†…å®¹æ—¶è¿”å›

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const scaleToFit = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scaleToFit * midX, fullHeight / 2 - scaleToFit * midY];

            // åº”ç”¨åˆå§‹å˜æ¢
            svg.call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scaleToFit));
        }

        // Reset view to center and fit
        function resetViewToCenter() {
            if (!g || !svg) return;

            try {
                // è·å–å†…å®¹è¾¹ç•Œ
                const bounds = g.node().getBBox();
                const svgRect = svg.node().getBoundingClientRect();
                const fullWidth = svgRect.width;
                const fullHeight = svgRect.height;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;

                if (width == 0 || height == 0) {
                    // å¦‚æœæ²¡æœ‰å†…å®¹ï¼Œåªæ˜¯å±…ä¸­
                    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
                    return;
                }

                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ä»¥é€‚åº”è§†å›¾
                const scaleToFit = 0.9 / Math.max(width / fullWidth, height / fullHeight);
                const translate = [fullWidth / 2 - scaleToFit * midX, fullHeight / 2 - scaleToFit * midY];

                // åº”ç”¨å˜æ¢ï¼Œå¸¦åŠ¨ç”»æ•ˆæœ
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scaleToFit));
            } catch (error) {
                console.warn('é‡ç½®è§†å›¾å¤±è´¥ï¼Œä½¿ç”¨ç®€å•é‡ç½®:', error);
                // å¦‚æœå‡ºé”™ï¼Œå›é€€åˆ°ç®€å•çš„é‡ç½®
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
            }
        }

        // Show node tooltip
        function showNodeTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');

            // è·å–å½“å‰æ—¶é—´æ­¥çš„åŠ¨æ€æ•°æ®
            let dynamicData = '';
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    // å°è¯•è·å–èŠ‚ç‚¹çš„åŠ¨æ€æ•°æ®
                    const pressure = getNodeValue(d.id, timeData.node_pressure);
                    const demand = getNodeValue(d.id, timeData.node_demand);

                    if (pressure !== undefined || demand !== undefined) {
                        // è®¡ç®—æ€»æ°´å¤´ = å‹åŠ› + é«˜ç¨‹
                        const totalHead = (pressure !== undefined && d.elevation !== undefined)
                            ? pressure + d.elevation
                            : undefined;

                        dynamicData = `
                            <div class="border-t border-gray-600 mt-2 pt-2">
                                <div class="text-yellow-300 font-medium">æ—¶é—´ ${currentTimeStep.toFixed(1)} å°æ—¶:</div>
                                ${pressure !== undefined ? `<div>å‹åŠ›: ${pressure.toFixed(2)} m</div>` : ''}
                                ${totalHead !== undefined ? `<div>æ€»æ°´å¤´: ${totalHead.toFixed(2)} m</div>` : ''}
                                ${demand !== undefined ? `<div>å®é™…éœ€æ°´é‡: ${demand.toFixed(3)} L/s</div>` : ''}
                            </div>
                        `;
                    }
                }
            }

            tooltip.innerHTML = `
                <div class="font-semibold">${d.type.toUpperCase()}: ${d.id}</div>
                <div class="text-xs mt-1">
                    <div>é«˜ç¨‹: ${d.elevation?.toFixed(2) || 'N/A'} m</div>
                    ${d.base_demand !== undefined ? `<div>åŸºç¡€éœ€æ°´é‡: ${d.base_demand.toFixed(3)} L/s</div>` : ''}
                    ${d.head !== undefined ? `<div>æ€»æ°´å¤´: ${d.head.toFixed(2)} m</div>` : ''}
                    ${d.init_level !== undefined ? `<div>åˆå§‹æ°´ä½: ${d.init_level.toFixed(2)} m</div>` : ''}
                    ${dynamicData}
                </div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }

        // Show link tooltip
        function showLinkTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');

            // è·å–å½“å‰æ—¶é—´æ­¥çš„åŠ¨æ€æ•°æ®
            let dynamicData = '';
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    // å°è¯•è·å–ç®¡æ®µçš„åŠ¨æ€æ•°æ®
                    const flow = getLinkValue(d.id, timeData.link_flow);
                    const velocity = getLinkValue(d.id, timeData.link_velocity);

                    if (flow !== undefined || velocity !== undefined) {
                        dynamicData = `
                            <div class="border-t border-gray-600 mt-2 pt-2">
                                <div class="text-yellow-300 font-medium">æ—¶é—´ ${currentTimeStep.toFixed(1)} å°æ—¶:</div>
                                ${flow !== undefined ? `<div>æµé‡: ${flow.toFixed(4)} L/s</div>` : ''}
                                ${velocity !== undefined ? `<div>æµé€Ÿ: ${velocity.toFixed(3)} m/s</div>` : ''}
                            </div>
                        `;
                    }
                }
            }

            tooltip.innerHTML = `
                <div class="font-semibold">${d.type.toUpperCase()}: ${d.id}</div>
                <div class="text-xs mt-1">
                    <div>èµ·ç‚¹: ${d.source.id || d.source}</div>
                    <div>ç»ˆç‚¹: ${d.target.id || d.target}</div>
                    ${d.length !== undefined ? `<div>ç®¡é•¿: ${d.length.toFixed(2)} m</div>` : ''}
                    ${d.diameter !== undefined ? `<div>ç®¡å¾„: ${d.diameter.toFixed(0)} mm</div>` : ''}
                    ${d.roughness !== undefined ? `<div>ç²—ç³™åº¦: ${d.roughness}</div>` : ''}
                    ${dynamicData}
                </div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Helper function to get time data with multiple format attempts
        function getTimeData(timeStep) {
            // æ£€æŸ¥æ•°æ®ç»“æ„
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (!dataSource) return null;

            // å°è¯•å¤šç§æ—¶é—´æ­¥æ ¼å¼åŒ¹é…
            let timeData = dataSource[timeStep.toString()];
            if (!timeData) {
                timeData = dataSource[Math.floor(timeStep).toString()];
            }
            if (!timeData) {
                timeData = dataSource[timeStep.toFixed(1)];
            }
            return timeData;
        }

        // Helper function to get node value with ID matching
        function getNodeValue(nodeId, dataObject) {
            if (!dataObject) return undefined;

            // å°è¯•å¤šç§IDæ ¼å¼åŒ¹é…
            let value = dataObject[nodeId];
            if (value === undefined) {
                value = dataObject[nodeId + '.0'];
            }
            if (value === undefined) {
                const idWithoutSuffix = nodeId.replace('.0', '');
                value = dataObject[idWithoutSuffix];
            }
            return value;
        }

        // Helper function to get link value with ID matching
        function getLinkValue(linkId, dataObject) {
            if (!dataObject) return undefined;

            // å°è¯•å¤šç§IDæ ¼å¼åŒ¹é…
            let value = dataObject[linkId];
            if (value === undefined) {
                value = dataObject[linkId + '.0'];
            }
            if (value === undefined) {
                const idWithoutSuffix = linkId.replace('.0', '');
                value = dataObject[idWithoutSuffix];
            }
            return value;
        }

        // Reset visualization colors to default topology colors
        function resetVisualizationColors() {
            if (!nodeElements || !linkElements) return;

            // Reset node colors to default type colors
            nodeElements.style('fill', d => {
                switch(d.type) {
                    case 'reservoir': return '#10b981'; // green
                    case 'tank': return '#f59e0b';      // yellow
                    case 'junction': return '#3b82f6';  // blue
                    default: return '#6b7280';          // gray
                }
            });

            // Reset link colors to default type colors
            linkElements.style('stroke', d => {
                switch(d.type) {
                    case 'pump': return '#ef4444';      // red
                    case 'valve': return '#8b5cf6';     // purple
                    case 'pipe': return '#6b7280';      // gray
                    default: return '#6b7280';          // gray
                }
            });

            console.log('å¯è§†åŒ–é¢œè‰²å·²é‡ç½®ä¸ºé»˜è®¤æ‹“æ‰‘é¢œè‰²');
        }

        // Show detailed node information
        function showNodeDetails(event, d) {
            let details = `èŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯:\n\nID: ${d.id}\nç±»å‹: ${d.type}\né«˜ç¨‹: ${d.elevation?.toFixed(2) || 'N/A'} m\nåŸºç¡€éœ€æ°´é‡: ${d.base_demand?.toFixed(3) || 'N/A'} L/s\næ€»æ°´å¤´: ${d.head?.toFixed(2) || 'N/A'} m`;

            // æ·»åŠ æ—¶é—´ç›¸å…³æ•°æ®
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    const pressure = getNodeValue(d.id, timeData.node_pressure);
                    const demand = getNodeValue(d.id, timeData.node_demand);

                    details += `\n\n=== æ—¶é—´ ${currentTimeStep.toFixed(1)} å°æ—¶ ===`;
                    if (pressure !== undefined) details += `\nå‹åŠ›: ${pressure.toFixed(2)} m`;

                    // è®¡ç®—æ€»æ°´å¤´ = å‹åŠ› + é«˜ç¨‹
                    if (pressure !== undefined && d.elevation !== undefined) {
                        const totalHead = pressure + d.elevation;
                        details += `\næ€»æ°´å¤´: ${totalHead.toFixed(2)} m`;
                    }

                    if (demand !== undefined) details += `\nå®é™…éœ€æ°´é‡: ${demand.toFixed(3)} L/s`;

                    if (pressure === undefined && demand === undefined) {
                        details += `\n(è¯¥æ—¶é—´æ­¥æ— åŠ¨æ€æ•°æ®)`;
                    }
                }
            }

            alert(details);
        }

        // Show detailed link information
        function showLinkDetails(event, d) {
            let details = `ç®¡æ®µè¯¦ç»†ä¿¡æ¯:\n\nID: ${d.id}\nç±»å‹: ${d.type}\nèµ·ç‚¹: ${d.source.id || d.source}\nç»ˆç‚¹: ${d.target.id || d.target}\nç®¡é•¿: ${d.length?.toFixed(2) || 'N/A'} m\nç®¡å¾„: ${d.diameter?.toFixed(0) || 'N/A'} mm\nç²—ç³™åº¦: ${d.roughness || 'N/A'}`;

            // æ·»åŠ æ—¶é—´ç›¸å…³æ•°æ®
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    const flow = getLinkValue(d.id, timeData.link_flow);
                    const velocity = getLinkValue(d.id, timeData.link_velocity);

                    details += `\n\n=== æ—¶é—´ ${currentTimeStep.toFixed(1)} å°æ—¶ ===`;
                    if (flow !== undefined) details += `\næµé‡: ${flow.toFixed(4)} L/s`;
                    if (velocity !== undefined) details += `\næµé€Ÿ: ${velocity.toFixed(3)} m/s`;

                    if (flow === undefined && velocity === undefined) {
                        details += `\n(è¯¥æ—¶é—´æ­¥æ— åŠ¨æ€æ•°æ®)`;
                    }
                }
            }

            alert(details);
        }

        // Update visualization data based on current time step
        function updateVisualizationData() {
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (!csvData || !dataSource || !nodeElements || !linkElements) {
                console.log('æ•°æ®å¯è§†åŒ–æ›´æ–°å¤±è´¥: ç¼ºå°‘å¿…è¦æ•°æ®', {
                    csvData: !!csvData,
                    data_by_time: !!dataSource,
                    nodeElements: !!nodeElements,
                    linkElements: !!linkElements
                });
                return;
            }

            // ä½¿ç”¨è¾…åŠ©å‡½æ•°è·å–æ—¶é—´æ•°æ®
            const timeData = getTimeData(currentTimeStep);
            if (!timeData) {
                console.log('æ—¶é—´æ­¥æ•°æ®ä¸å­˜åœ¨:', currentTimeStep, 'å¯ç”¨æ—¶é—´æ­¥:', Object.keys(dataSource));
                return;
            }

            console.log('å¼€å§‹æ›´æ–°å¯è§†åŒ–æ•°æ®:', {
                timeStep: currentTimeStep,
                nodePressureCount: Object.keys(timeData.node_pressure || {}).length,
                linkFlowCount: Object.keys(timeData.link_flow || {}).length
            });

            // æ›´æ–°èŠ‚ç‚¹é¢œè‰²åŸºäºå‹åŠ›å€¼
            nodeElements.style('fill', function(d) {
                // å°è¯•å¤šç§IDæ ¼å¼åŒ¹é…
                let pressure = timeData.node_pressure[d.id];
                if (pressure === undefined) {
                    // å°è¯•æ·»åŠ .0åç¼€
                    pressure = timeData.node_pressure[d.id + '.0'];
                }
                if (pressure === undefined) {
                    // å°è¯•ç§»é™¤.0åç¼€
                    const idWithoutSuffix = d.id.replace('.0', '');
                    pressure = timeData.node_pressure[idWithoutSuffix];
                }

                if (pressure !== undefined) {
                    // å‹åŠ›å€¼æ˜ å°„åˆ°é¢œè‰² (è“è‰²=ä½å‹ï¼Œçº¢è‰²=é«˜å‹)
                    const normalizedPressure = Math.min(1, Math.max(0, pressure / 50)); // è°ƒæ•´æœ€å¤§å‹åŠ›ä¸º50m
                    const hue = (1 - normalizedPressure) * 240; // 240=è“è‰², 0=çº¢è‰²
                    return `hsl(${hue}, 70%, 50%)`;
                }
                // ä¿æŒåŸæœ‰çš„èŠ‚ç‚¹ç±»å‹é¢œè‰²
                if (d.type === 'reservoir') return '#10b981';
                if (d.type === 'tank') return '#f59e0b';
                return '#3b82f6'; // junctioné»˜è®¤è“è‰²
            });

            // æ›´æ–°ç®¡æ®µé¢œè‰²åŸºäºæµé‡
            linkElements.style('stroke', function(d) {
                // å°è¯•å¤šç§IDæ ¼å¼åŒ¹é…
                let flow = timeData.link_flow[d.id];
                if (flow === undefined) {
                    // å°è¯•æ·»åŠ .0åç¼€
                    flow = timeData.link_flow[d.id + '.0'];
                }
                if (flow === undefined) {
                    // å°è¯•ç§»é™¤.0åç¼€
                    const idWithoutSuffix = d.id.replace('.0', '');
                    flow = timeData.link_flow[idWithoutSuffix];
                }

                if (flow !== undefined) {
                    const absFlow = Math.abs(flow);
                    const normalizedFlow = Math.min(1, absFlow / 200); // è°ƒæ•´æœ€å¤§æµé‡ä¸º200 L/s
                    const intensity = Math.floor(normalizedFlow * 200 + 55); // ç¡®ä¿é¢œè‰²å¯è§
                    return flow >= 0 ? `rgb(0, ${intensity}, 0)` : `rgb(${intensity}, 0, 0)`;
                }
                // ä¿æŒåŸæœ‰çš„ç®¡æ®µç±»å‹é¢œè‰²
                if (d.type === 'pump') return '#ef4444';
                if (d.type === 'valve') return '#8b5cf6';
                return '#6b7280'; // pipeé»˜è®¤ç°è‰²
            });

            console.log('å¯è§†åŒ–æ•°æ®æ›´æ–°å®Œæˆ');
        }

        // Update node sizes
        function updateNodeSizes() {
            if (!nodeElements) return;

            nodeElements.attr('r', d => {
                const baseRadius = d.type === 'reservoir' ? 12 : d.type === 'tank' ? 10 : 6;
                return baseRadius * nodeSizeScale;
            });
        }

        // Update link sizes
        function updateLinkSizes() {
            if (!linkElements) return;

            linkElements.attr('stroke-width', function(d) {
                const baseWidth = d.type === 'pump' ? 4 : d.type === 'valve' ? 3 : Math.max(1, Math.min(8, (d.diameter || 100) / 50));
                return baseWidth * linkSizeScale;
            });
        }

        // Update node labels visibility
        function updateNodeLabelsVisibility() {
            if (!nodeLabels) return;
            nodeLabels.style('display', showNodeIds ? 'block' : 'none');
        }

        // Update link labels visibility
        function updateLinkLabelsVisibility() {
            if (!linkLabels) return;
            linkLabels.style('display', showLinkIds ? 'block' : 'none');
        }
    </script>
</html>
