<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Topology - LeakAgent</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- D3.js for network visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Google Fonts (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #171717;
        }

        .network-svg {
            background: #1f2937;
            border-radius: 8px;
        }

        .node {
            cursor: pointer;
            stroke-width: 2;
        }

        .node.junction {
            fill: #3b82f6;
            stroke: #1d4ed8;
        }

        .node.reservoir {
            fill: #10b981;
            stroke: #047857;
        }

        .node.tank {
            fill: #f59e0b;
            stroke: #d97706;
        }

        .link {
            cursor: pointer;
        }

        .link.pipe {
            stroke: #6b7280;
        }

        .link.pump {
            stroke: #ef4444;
        }

        .link.valve {
            stroke: #8b5cf6;
        }

        .node:hover,
        .link:hover {
            filter: brightness(1.2);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
        }

        .file-item {
            transition: all 0.2s ease;
        }

        .file-item:hover {
            background-color: #374151;
        }

        .file-item.selected {
            background-color: #1d4ed8;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #171717;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4A4A4A;
            border-radius: 4px;
            border: 2px solid #171717;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6c6c6c;
        }
    </style>
</head>

<body class="text-gray-200">
    <!-- Top Navigation Bar -->
    <nav class="bg-gray-800 border-b border-white/10 px-4 py-3">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-6">
                <h1 class="text-xl font-semibold text-white">LeakAgent Water Supply Network Domain LLM</h1>
                <div class="flex space-x-4">
                    <a href="/"
                        class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700 transition-colors">
                        üí¨ Chat
                    </a>
                    <a href="/topology"
                        class="px-3 py-2 rounded-md text-sm font-medium text-white bg-gray-700 hover:bg-gray-600 transition-colors">
                        üó∫Ô∏èTopology
                    </a>
                </div>
            </div>
            <div class="text-sm text-gray-400">
                Network Topology Visualization and Data Analysis
            </div>
        </div>
    </nav>

    <div class="flex h-[calc(100vh-60px)]">
        <!-- Left Sidebar -->
        <aside class="w-80 bg-gray-900 border-r border-white/10 flex flex-col">
            <!-- File Selection -->
            <div class="p-4 border-b border-white/10">
                <h2 class="text-lg font-semibold mb-4">üìÅ File Selection</h2>

                <!-- INP Files -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-400 mb-2">Network Files (.inp)</h3>
                    <div id="inp-files-list" class="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">
                        <div class="text-center text-gray-500 py-4">
                            <div
                                class="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full mx-auto mb-2">
                            </div>
                            Loading...
                        </div>
                    </div>
                </div>

                <!-- CSV Files -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-400 mb-2">Data Files (.csv)</h3>
                    <div id="csv-files-list" class="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">
                        <div class="text-center text-gray-500 py-4">
                            Please select network file first
                        </div>
                    </div>
                </div>

                <!-- Load Button -->
                <button id="load-topology-btn"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled>
                    üó∫Ô∏è Load Topology
                </button>
            </div>

            <!-- Network Info -->
            <div class="p-4 border-b border-white/10">
                <h3 class="text-sm font-medium text-gray-400 mb-2">üìä Network Info</h3>
                <div id="network-info" class="text-sm text-gray-300 space-y-1">
                    <div>Please select network file</div>
                </div>
            </div>


        </aside>

        <!-- Main Content -->
        <main class="flex-1 flex flex-col relative">
            <!-- Toolbar -->
            <div class="bg-gray-800 border-b border-white/10 px-4 py-3">
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center space-x-4">
                        <h2 class="text-lg font-semibold">Network Topology</h2>
                        <div id="current-file-info" class="text-sm text-gray-400">
                            No file selected
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="zoom-in-btn"
                            class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            üîç+
                        </button>
                        <button id="zoom-out-btn"
                            class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            üîç-
                        </button>
                        <button id="reset-view-btn"
                            class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            üéØ Reset View
                        </button>
                        <button id="legend-toggle"
                            class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors">
                            üé® Legend
                        </button>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="flex items-center justify-between space-x-6">
                    <!-- Time Control -->
                    <div id="time-controls" class="flex items-center space-x-3" style="display: none;">
                        <span class="text-sm text-gray-400">Time:</span>
                        <input type="range" id="time-slider" min="0" max="24" step="1" value="0"
                            class="w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <span id="time-display" class="text-sm text-white min-w-[60px]">0.0 Hours</span>
                    </div>

                    <!-- Size Control -->
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-400">Node:</span>
                            <input type="range" id="node-size-slider" min="0.0" max="3" step="0.1" value="1"
                                class="w-20 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-400">Link:</span>
                            <input type="range" id="link-size-slider" min="0.0" max="3" step="0.1" value="1"
                                class="w-20 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <!-- ID Display Control -->
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="show-node-ids"
                                class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                            <label for="show-node-ids" class="text-sm text-gray-400">Node ID</label>
                        </div>
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="show-link-ids"
                                class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                            <label for="show-link-ids" class="text-sm text-gray-400">Link ID</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Visualization Area -->
            <div class="flex-1 p-4">
                <div id="topology-container"
                    class="w-full h-full bg-gray-800 rounded-lg border border-white/10 relative">
                    <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center">
                        <div class="text-center">
                            <div class="text-6xl mb-4">üó∫Ô∏è</div>
                            <div class="text-xl text-gray-400">Select network file to start visualization</div>
                            <div class="text-sm text-gray-500 mt-2">Supports EPANET .inp format files</div>
                        </div>
                    </div>
                    <!-- Floating Legend -->
                    <div id="legend-panel"
                        class="absolute top-4 right-4 z-10 bg-gray-800/95 backdrop-blur-sm border border-white/20 rounded-lg p-3 shadow-lg min-w-[180px]"
                        style="display: none;">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-medium text-gray-300">üé® Legend</h3>
                            <button id="legend-close"
                                class="text-gray-400 hover:text-white text-lg leading-none">&times;</button>
                        </div>
                        <div class="space-y-3 text-xs">
                            <!-- Node Type -->
                            <div class="space-y-1">
                                <div class="text-xs text-gray-400 font-medium">Node Type</div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-blue-500"></div>
                                    <span class="text-gray-300">Junction</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-green-500"></div>
                                    <span class="text-gray-300">Reservoir</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-yellow-500"></div>
                                    <span class="text-gray-300">Tank</span>
                                </div>
                            </div>

                            <!-- Link Type -->
                            <div class="space-y-1">
                                <div class="text-xs text-gray-400 font-medium">Link Type</div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-0.5 bg-gray-500"></div>
                                    <span class="text-gray-300">Pipe</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-1 bg-red-500"></div>
                                    <span class="text-gray-300">Pump</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-1 bg-purple-500"></div>
                                    <span class="text-gray-300">Valve</span>
                                </div>
                            </div>

                            <!-- Data Color Legend -->
                            <div id="data-legend" class="space-y-1" style="display: none;">
                                <div class="text-xs text-gray-400 font-medium">Data Color</div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-blue-400"></div>
                                    <span class="text-gray-300">Low Pressure</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-2.5 h-2.5 rounded-full bg-red-400"></div>
                                    <span class="text-gray-300">High Pressure</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-0.5 bg-green-400"></div>
                                    <span class="text-gray-300">Positive Flow</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="w-5 h-0.5 bg-red-400"></div>
                                    <span class="text-gray-300">Negative Flow</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <svg id="network-svg" class="w-full h-full network-svg" style="display: none;"></svg>
                </div>
            </div>
        </main>
    </div>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <script>
        // Global variables
        let currentInpFile = null;
        let currentCsvFile = null;
        let networkData = null;
        let csvData = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let currentTimeStep = 0;
        let nodeElements = null;
        let linkElements = null;
        let nodeLabels = null;
        let linkLabels = null;
        let nodeSizeScale = 1;
        let linkSizeScale = 1;
        let showNodeIds = false;
        let showLinkIds = false;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function () {
            loadInpFiles();
            loadCsvFiles();
            initializeVisualization();
        });

        // Load INP files
        async function loadInpFiles() {
            try {
                const response = await fetch('/api/inp_files');
                const data = await response.json();

                const container = document.getElementById('inp-files-list');

                if (data.success && data.files.length > 0) {
                    container.innerHTML = '';
                    data.files.forEach(file => {
                        const fileItem = createFileItem(file, 'inp');
                        container.appendChild(fileItem);
                    });
                } else {
                    container.innerHTML = '<div class="text-center text-gray-500 py-4">No network files</div>';
                }
            } catch (error) {
                console.error('Failed to load INP files:', error);
                document.getElementById('inp-files-list').innerHTML = '<div class="text-center text-red-500 py-4">Load failed</div>';
            }
        }

        // Load CSV files
        async function loadCsvFiles() {
            try {
                const response = await fetch('/api/csv_files');
                const data = await response.json();

                const container = document.getElementById('csv-files-list');

                if (data.success && data.files.length > 0) {
                    container.innerHTML = '';
                    data.files.forEach(file => {
                        const fileItem = createFileItem(file, 'csv');
                        container.appendChild(fileItem);
                    });
                } else {
                    container.innerHTML = '<div class="text-center text-gray-500 py-4">No data files</div>';
                }
            } catch (error) {
                console.error('Failed to load CSV files:', error);
                document.getElementById('csv-files-list').innerHTML = '<div class="text-center text-red-500 py-4">Load failed</div>';
            }
        }

        // Create file item element
        function createFileItem(file, type) {
            const div = document.createElement('div');
            div.className = 'file-item p-3 rounded-lg border border-gray-700 cursor-pointer';
            div.dataset.filePath = file.path;
            div.dataset.fileType = type;

            const icon = type === 'inp' ? 'üìÑ' : 'üìä';
            const size = (file.size / 1024).toFixed(1) + ' KB';
            const date = new Date(file.modified).toLocaleDateString('en-US');

            // Add file source indicator
            let sourceIcon = '';
            let sourceText = '';
            if (type === 'inp' && file.source) {
                if (file.source === 'uploaded') {
                    sourceIcon = 'üì§';
                    sourceText = 'Uploaded';
                } else if (file.source === 'example') {
                    sourceIcon = 'üìã';
                    sourceText = 'Example';
                }
            }

            div.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center space-x-2">
                            <span class="text-lg">${icon}</span>
                            <span class="text-sm font-medium truncate">${file.filename}</span>
                            ${sourceIcon ? `<span class="text-xs px-1.5 py-0.5 bg-gray-600 rounded text-gray-300">${sourceIcon} ${sourceText}</span>` : ''}
                        </div>
                        <div class="text-xs text-gray-400 mt-1">
                            ${size} ‚Ä¢ ${date}
                        </div>
                    </div>
                </div>
            `;

            // Add click and double click event handlers
            let clickTimeout;
            div.addEventListener('click', (e) => {
                clearTimeout(clickTimeout);
                clickTimeout = setTimeout(() => {
                    selectFile(file, type, div);
                }, 250); // 250ms delay to distinguish single and double click
            });

            div.addEventListener('dblclick', (e) => {
                clearTimeout(clickTimeout);
                deselectFile(type, div);
            });

            return div;
        }

        // Select file
        function selectFile(file, type, element) {
            if (type === 'inp') {
                // Clear previous selection
                document.querySelectorAll('#inp-files-list .file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                element.classList.add('selected');
                currentInpFile = file;

                // Update network info
                updateNetworkInfo();

                // Enable load button if both files selected
                updateLoadButton();
            } else if (type === 'csv') {
                // Clear previous selection
                document.querySelectorAll('#csv-files-list .file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                element.classList.add('selected');
                currentCsvFile = file;

                // Enable load button if both files selected
                updateLoadButton();
            }
        }

        // Deselect file (double click to unselect)
        function deselectFile(type, element) {
            if (type === 'inp') {
                element.classList.remove('selected');
                currentInpFile = null;
                networkData = null; // Clear network data cache

                // Clear network info
                document.getElementById('network-info').innerHTML = '<div>Please select network file</div>';

                // Clear topology if loaded
                if (document.getElementById('topology-svg')) {
                    document.getElementById('topology-container').innerHTML = `
                        <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center">
                            <div class="text-center">
                                <div class="text-6xl mb-4">üó∫Ô∏è</div>
                                <div class="text-xl text-gray-400">Select network file to start visualization</div>
                                <div class="text-sm text-gray-500 mt-2">Supports EPANET .inp format files</div>
                            </div>
                        </div>
                    `;
                }

                // Update load button
                updateLoadButton();
            } else if (type === 'csv') {
                element.classList.remove('selected');
                currentCsvFile = null;
                csvData = null;

                // Hide time controls
                document.getElementById('time-controls').style.display = 'none';

                // Hide data legend
                document.getElementById('data-legend').style.display = 'none';

                // Reset visualization to show only topology colors
                if (nodeElements && linkElements) {
                    resetVisualizationColors();
                }

                // Update load button
                updateLoadButton();
            }
        }

        // Ensure network data is loaded
        async function ensureNetworkDataLoaded() {
            if (!currentInpFile) {
                throw new Error('No INP file selected');
            }

            if (networkData) {
                console.log('Network data already exists, skipping load');
                return networkData;
            }

            console.log('Loading network data...');
            const response = await fetch(`/api/network_topology/${encodeURIComponent(currentInpFile.path)}`);
            const data = await response.json();

            if (data.success) {
                networkData = data.topology;
                console.log('Network data loaded successfully:', {
                    nodes: networkData.nodes.total,
                    links: networkData.links.total
                });

                // Also update network info display
                updateNetworkInfoDisplay();

                return networkData;
            } else {
                throw new Error(data.error || 'Failed to load network data');
            }
        }

        // Update network info display
        function updateNetworkInfoDisplay() {
            if (!networkData) return;

            const infoContainer = document.getElementById('network-info');
            infoContainer.innerHTML = `
                <div>Total Nodes: ${networkData.nodes.total}</div>
                <div>‚Ä¢ Junctions: ${networkData.nodes.junctions}</div>
                <div>‚Ä¢ Reservoirs: ${networkData.nodes.reservoirs}</div>
                <div>‚Ä¢ Tanks: ${networkData.nodes.tanks}</div>
                <div class="mt-2">Total Links: ${networkData.links.total}</div>
                <div>‚Ä¢ Pipes: ${networkData.links.pipes}</div>
                <div>‚Ä¢ Pumps: ${networkData.links.pumps}</div>
                <div>‚Ä¢ Valves: ${networkData.links.valves}</div>
                <div class="mt-2">Total Length: ${networkData.network_stats && networkData.network_stats.total_length ? networkData.network_stats.total_length.toFixed(2) : 'N/A'} m</div>
            `;
        }

        // Update network info (legacy function for file selection)
        async function updateNetworkInfo() {
            if (!currentInpFile) return;

            const infoContainer = document.getElementById('network-info');
            infoContainer.innerHTML = '<div class="animate-pulse">Loading network info...</div>';

            try {
                await ensureNetworkDataLoaded();
            } catch (error) {
                console.error('Failed to get network info:', error);
                infoContainer.innerHTML = '<div class="text-red-400">Load failed</div>';
            }
        }

        // Update load button state
        function updateLoadButton() {
            const loadBtn = document.getElementById('load-topology-btn');
            loadBtn.disabled = !currentInpFile;

            if (currentInpFile) {
                loadBtn.textContent = currentCsvFile ? 'üó∫Ô∏è Load Topology (with data)' : 'üó∫Ô∏è Load Topology';
            } else {
                loadBtn.textContent = 'üó∫Ô∏è Load Topology';
            }
        }

        // Initialize visualization
        function initializeVisualization() {
            svg = d3.select('#network-svg');
            g = svg.append('g');

            // Setup zoom
            zoom = d3.zoom()
                .scaleExtent([0.001, 200])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Zoom controls
            document.getElementById('zoom-in-btn').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1.5);
            });

            document.getElementById('zoom-out-btn').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            });

            document.getElementById('reset-view-btn').addEventListener('click', () => {
                resetViewToCenter();
            });

            // Load topology button
            document.getElementById('load-topology-btn').addEventListener('click', loadTopology);

            // Time slider
            document.getElementById('time-slider').addEventListener('input', (e) => {
                currentTimeStep = parseFloat(e.target.value);
                document.getElementById('time-display').textContent = `${currentTimeStep.toFixed(1)} Hours`;
                updateVisualizationData();
                // Ensure size settings are not overwritten
                updateNodeSizes();
                updateLinkSizes();
            });

            // Size sliders
            document.getElementById('node-size-slider').addEventListener('input', (e) => {
                nodeSizeScale = parseFloat(e.target.value);
                updateNodeSizes();
            });

            document.getElementById('link-size-slider').addEventListener('input', (e) => {
                linkSizeScale = parseFloat(e.target.value);
                updateLinkSizes();
            });

            // ID display toggles
            document.getElementById('show-node-ids').addEventListener('change', (e) => {
                showNodeIds = e.target.checked;
                updateNodeLabelsVisibility();
            });

            document.getElementById('show-link-ids').addEventListener('change', (e) => {
                showLinkIds = e.target.checked;
                updateLinkLabelsVisibility();
            });

            // Legend controls
            document.getElementById('legend-toggle').addEventListener('click', () => {
                const legendPanel = document.getElementById('legend-panel');
                if (legendPanel.style.display === 'none') {
                    legendPanel.style.display = 'block';
                } else {
                    legendPanel.style.display = 'none';
                }
            });

            document.getElementById('legend-close').addEventListener('click', () => {
                document.getElementById('legend-panel').style.display = 'none';
            });
        }

        // Load topology
        async function loadTopology() {
            if (!currentInpFile) return;

            const loadingIndicator = document.getElementById('loading-indicator');
            const networkSvg = document.getElementById('network-svg');

            loadingIndicator.innerHTML = `
                <div class="text-center">
                    <div class="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <div class="text-xl text-gray-400">Loading network data...</div>
                </div>
            `;

            try {
                // Ensure network data is loaded
                if (!networkData) {
                    console.log('Network data not loaded, fetching...');
                    await ensureNetworkDataLoaded();
                }

                // Update loading status
                loadingIndicator.innerHTML = `
                    <div class="text-center">
                        <div class="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                        <div class="text-xl text-gray-400">Generating topology...</div>
                    </div>
                `;

                // Load CSV data if selected
                if (currentCsvFile) {
                    await loadCsvData();
                }

                // Generate topology visualization
                await generateTopology();

                // Update visualization with current data
                updateVisualizationData();

                // Apply initial size settings
                updateNodeSizes();
                updateLinkSizes();

                // Hide loading, show SVG
                loadingIndicator.style.display = 'none';
                networkSvg.style.display = 'block';

                // Update current file info
                document.getElementById('current-file-info').textContent =
                    `${currentInpFile.filename}${currentCsvFile ? ' + ' + currentCsvFile.filename : ''}`;

            } catch (error) {
                console.error('Failed to load topology:', error);
                loadingIndicator.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4 text-red-500">‚ùå</div>
                        <div class="text-xl text-red-400">Load failed</div>
                        <div class="text-sm text-gray-500 mt-2">${error.message}</div>
                    </div>
                `;
            }
        }

        // Load CSV data
        async function loadCsvData() {
            if (!currentCsvFile) {
                csvData = null;
                return;
            }

            try {
                const response = await fetch(`/api/csv_data/${encodeURIComponent(currentCsvFile.path)}`);
                const data = await response.json();

                if (data.success) {
                    csvData = data.csv_data;

                    // Set time slider range
                    const timeSlider = document.getElementById('time-slider');
                    const timeSteps = csvData.time_steps || Object.keys(csvData.data_by_time || {}).map(t => parseFloat(t)).sort((a, b) => a - b);
                    if (timeSteps && timeSteps.length > 0) {
                        timeSlider.min = timeSteps[0];
                        timeSlider.max = timeSteps[timeSteps.length - 1];
                        timeSlider.value = timeSteps[0];
                        currentTimeStep = timeSteps[0];

                        // Set step to minimum interval between time steps
                        if (timeSteps.length > 1) {
                            const minStep = Math.min(...timeSteps.slice(1).map((t, i) => t - timeSteps[i]));
                            timeSlider.step = minStep;
                        }

                        document.getElementById('time-display').textContent = `${currentTimeStep.toFixed(1)} Hours`;
                    }

                    // Show time controls
                    document.getElementById('time-controls').style.display = 'flex';

                    // Show data legend
                    document.getElementById('data-legend').style.display = 'block';

                    // Automatically show legend panel
                    document.getElementById('legend-panel').style.display = 'block';

                    // Update visualization data immediately
                    updateVisualizationData();

                    console.log('CSV data loaded successfully:', csvData.summary);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                console.error('Failed to load CSV data:', error);
                csvData = null;
                document.getElementById('time-controls').style.display = 'none';
            }
        }

        // Generate topology visualization
        async function generateTopology() {
            // Clear previous visualization
            g.selectAll('*').remove();

            if (!networkData || !networkData.topology) {
                throw new Error('Network topology data unavailable');
            }

            const nodes = networkData.topology.nodes;
            const links = networkData.topology.links;

            if (nodes.length === 0) {
                throw new Error('Network has no node data');
            }

            // Calculate coordinate range
            const xCoords = nodes.map(n => n.coordinates[0]).filter(x => x !== undefined && x !== null);
            const yCoords = nodes.map(n => n.coordinates[1]).filter(y => y !== undefined && y !== null);

            let xMin = Math.min(...xCoords);
            let xMax = Math.max(...xCoords);
            let yMin = Math.min(...yCoords);
            let yMax = Math.max(...yCoords);

            // If no valid coordinates, use default range
            if (!isFinite(xMin) || !isFinite(xMax) || !isFinite(yMin) || !isFinite(yMax)) {
                xMin = 0; xMax = 1000; yMin = 0; yMax = 1000;
            }

            // Add margin
            const margin = Math.max((xMax - xMin), (yMax - yMin)) * 0.1;
            xMin -= margin; xMax += margin;
            yMin -= margin; yMax += margin;

            // Get SVG dimensions
            const svgRect = svg.node().getBoundingClientRect();
            const svgWidth = svgRect.width;
            const svgHeight = svgRect.height;

            // Calculate scale
            const scaleX = svgWidth / (xMax - xMin);
            const scaleY = svgHeight / (yMax - yMin);
            const scale = Math.min(scaleX, scaleY) * 0.9; // Leave some margin

            // Prepare data
            const nodeData = nodes.map(node => {
                let x = node.coordinates[0];
                let y = node.coordinates[1];

                // If no coordinates, assign randomly
                if (x === undefined || x === null || y === undefined || y === null) {
                    x = xMin + Math.random() * (xMax - xMin);
                    y = yMin + Math.random() * (yMax - yMin);
                }

                // Transform coordinates (Flip Y axis as SVG Y axis is down)
                const transformedX = (x - xMin) * scale;
                const transformedY = svgHeight - (y - yMin) * scale;

                return {
                    id: node.id,
                    type: node.type,
                    x: transformedX,
                    y: transformedY,
                    originalX: x,
                    originalY: y,
                    elevation: node.elevation || 0,
                    base_demand: node.base_demand || 0,
                    head: node.head || 0,
                    ...node
                };
            });

            const linkData = links.map(link => ({
                source: link.start_node,
                target: link.end_node,
                id: link.id,
                type: link.type,
                length: link.length || 0,
                diameter: link.diameter || 0,
                ...link
            }));

            // Create node ID to data mapping
            const nodeMap = new Map();
            nodeData.forEach(node => nodeMap.set(node.id, node));

            // Create links
            const linkGroup = g.append('g').attr('class', 'links');
            linkElements = linkGroup.selectAll('line')
                .data(linkData)
                .enter().append('line')
                .attr('class', d => `link ${d.type}`)
                .attr('stroke-width', d => {
                    const baseWidth = d.type === 'pump' ? 4 : d.type === 'valve' ? 3 : Math.max(1, Math.min(8, (d.diameter || 100) / 50));
                    return baseWidth * linkSizeScale;
                })
                .attr('x1', d => {
                    const sourceNode = nodeMap.get(d.source);
                    return sourceNode ? sourceNode.x : 0;
                })
                .attr('y1', d => {
                    const sourceNode = nodeMap.get(d.source);
                    return sourceNode ? sourceNode.y : 0;
                })
                .attr('x2', d => {
                    const targetNode = nodeMap.get(d.target);
                    return targetNode ? targetNode.x : 0;
                })
                .attr('y2', d => {
                    const targetNode = nodeMap.get(d.target);
                    return targetNode ? targetNode.y : 0;
                })
                .on('mouseover', showLinkTooltip)
                .on('mouseout', hideTooltip)
                .on('click', showLinkDetails);

            // Create nodes
            nodeElements = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodeData)
                .enter().append('circle')
                .attr('class', d => `node ${d.type}`)
                .attr('r', d => {
                    const baseRadius = d.type === 'reservoir' ? 12 : d.type === 'tank' ? 10 : 6;
                    return baseRadius * nodeSizeScale;
                })
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .on('mouseover', showNodeTooltip)
                .on('mouseout', hideTooltip)
                .on('click', showNodeDetails);

            // Add node labels
            nodeLabels = g.append('g')
                .attr('class', 'node-labels')
                .selectAll('text')
                .data(nodeData)
                .enter().append('text')
                .attr('x', d => d.x + 12)
                .attr('y', d => d.y + 4)
                .attr('font-size', '10px')
                .attr('fill', '#9ca3af')
                .style('display', 'none') // Hidden by default
                .text(d => d.id);

            // Add link labels
            linkLabels = g.append('g')
                .attr('class', 'link-labels')
                .selectAll('text')
                .data(linkData)
                .enter().append('text')
                .attr('x', d => {
                    const sourceNode = nodeMap.get(d.source);
                    const targetNode = nodeMap.get(d.target);
                    return sourceNode && targetNode ? (sourceNode.x + targetNode.x) / 2 : 0;
                })
                .attr('y', d => {
                    const sourceNode = nodeMap.get(d.source);
                    const targetNode = nodeMap.get(d.target);
                    return sourceNode && targetNode ? (sourceNode.y + targetNode.y) / 2 : 0;
                })
                .attr('font-size', '9px')
                .attr('fill', '#6b7280')
                .attr('text-anchor', 'middle')
                .style('display', 'none') // Hidden by default
                .text(d => d.id);

            // Auto zoom to fit view
            const bounds = g.node().getBBox();
            const fullWidth = svgWidth;
            const fullHeight = svgHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width == 0 || height == 0) return; // Return if no content

            // Calculate scale to fit view
            const scaleToFit = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scaleToFit * midX, fullHeight / 2 - scaleToFit * midY];

            // Apply initial transform
            svg.call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scaleToFit));
        }

        // Reset view to center and fit
        function resetViewToCenter() {
            if (!g || !svg) return;

            try {
                // Get content bounds
                const bounds = g.node().getBBox();
                const svgRect = svg.node().getBoundingClientRect();
                const fullWidth = svgRect.width;
                const fullHeight = svgRect.height;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;

                if (width == 0 || height == 0) {
                    // If no content, just center
                    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
                    return;
                }

                // Calculate scale to fit view
                const scaleToFit = 0.9 / Math.max(width / fullWidth, height / fullHeight);
                const translate = [fullWidth / 2 - scaleToFit * midX, fullHeight / 2 - scaleToFit * midY];

                // Apply transform with animation
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scaleToFit));
            } catch (error) {
                console.warn('Reset view failed, using simple reset:', error);
                // Fallback to simple reset on error
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
            }
        }

        // Show node tooltip
        function showNodeTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');

            // Get dynamic data for current time step
            let dynamicData = '';
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    // Try to get node dynamic data
                    const pressure = getNodeValue(d.id, timeData.node_pressure);
                    const demand = getNodeValue(d.id, timeData.node_demand);

                    if (pressure !== undefined || demand !== undefined) {
                        // Calculate total head = pressure + elevation
                        const totalHead = (pressure !== undefined && d.elevation !== undefined)
                            ? pressure + d.elevation
                            : undefined;

                        dynamicData = `
                            <div class="border-t border-gray-600 mt-2 pt-2">
                                <div class="text-yellow-300 font-medium">Time ${currentTimeStep.toFixed(1)} Hours:</div>
                                ${pressure !== undefined ? `<div>Pressure: ${pressure.toFixed(2)} m</div>` : ''}
                                ${totalHead !== undefined ? `<div>Total Head: ${totalHead.toFixed(2)} m</div>` : ''}
                                ${demand !== undefined ? `<div>Actual Demand: ${demand.toFixed(3)} L/s</div>` : ''}
                            </div>
                        `;
                    }
                }
            }

            tooltip.innerHTML = `
                <div class="font-semibold">${d.type.toUpperCase()}: ${d.id}</div>
                <div class="text-xs mt-1">
                    <div>Elevation: ${d.elevation?.toFixed(2) || 'N/A'} m</div>
                    ${d.base_demand !== undefined ? `<div>Base Demand: ${d.base_demand.toFixed(3)} L/s</div>` : ''}
                    ${d.head !== undefined ? `<div>Total Head: ${d.head.toFixed(2)} m</div>` : ''}
                    ${d.init_level !== undefined ? `<div>Initial Level: ${d.init_level.toFixed(2)} m</div>` : ''}
                    ${dynamicData}
                </div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }

        // Show link tooltip
        function showLinkTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');

            // Get dynamic data for current time step
            let dynamicData = '';
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    // Try to get link dynamic data
                    const flow = getLinkValue(d.id, timeData.link_flow);
                    const velocity = getLinkValue(d.id, timeData.link_velocity);

                    if (flow !== undefined || velocity !== undefined) {
                        dynamicData = `
                            <div class="border-t border-gray-600 mt-2 pt-2">
                                <div class="text-yellow-300 font-medium">Time ${currentTimeStep.toFixed(1)} Hours:</div>
                                ${flow !== undefined ? `<div>Flow: ${flow.toFixed(4)} L/s</div>` : ''}
                                ${velocity !== undefined ? `<div>Velocity: ${velocity.toFixed(3)} m/s</div>` : ''}
                            </div>
                        `;
                    }
                }
            }

            tooltip.innerHTML = `
                <div class="font-semibold">${d.type.toUpperCase()}: ${d.id}</div>
                <div class="text-xs mt-1">
                    <div>Start Node: ${d.source.id || d.source}</div>
                    <div>End Node: ${d.target.id || d.target}</div>
                    ${d.length !== undefined ? `<div>Length: ${d.length.toFixed(2)} m</div>` : ''}
                    ${d.diameter !== undefined ? `<div>Diameter: ${d.diameter.toFixed(0)} mm</div>` : ''}
                    ${d.roughness !== undefined ? `<div>Roughness: ${d.roughness}</div>` : ''}
                    ${dynamicData}
                </div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Helper function to get time data with multiple format attempts
        function getTimeData(timeStep) {
            // Check data structure
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (!dataSource) return null;

            // Try matching multiple time step formats
            let timeData = dataSource[timeStep.toString()];
            if (!timeData) {
                timeData = dataSource[Math.floor(timeStep).toString()];
            }
            if (!timeData) {
                timeData = dataSource[timeStep.toFixed(1)];
            }
            return timeData;
        }

        // Helper function to get node value with ID matching
        function getNodeValue(nodeId, dataObject) {
            if (!dataObject) return undefined;

            // Try matching multiple ID formats
            let value = dataObject[nodeId];
            if (value === undefined) {
                value = dataObject[nodeId + '.0'];
            }
            if (value === undefined) {
                const idWithoutSuffix = nodeId.replace('.0', '');
                value = dataObject[idWithoutSuffix];
            }
            return value;
        }

        // Helper function to get link value with ID matching
        function getLinkValue(linkId, dataObject) {
            if (!dataObject) return undefined;

            // Try matching multiple ID formats
            let value = dataObject[linkId];
            if (value === undefined) {
                value = dataObject[linkId + '.0'];
            }
            if (value === undefined) {
                const idWithoutSuffix = linkId.replace('.0', '');
                value = dataObject[idWithoutSuffix];
            }
            return value;
        }

        // Reset visualization colors to default topology colors
        function resetVisualizationColors() {
            if (!nodeElements || !linkElements) return;

            // Reset node colors to default type colors
            nodeElements.style('fill', d => {
                switch (d.type) {
                    case 'reservoir': return '#10b981'; // green
                    case 'tank': return '#f59e0b';      // yellow
                    case 'junction': return '#3b82f6';  // blue
                    default: return '#6b7280';          // gray
                }
            });

            // Reset link colors to default type colors
            linkElements.style('stroke', d => {
                switch (d.type) {
                    case 'pump': return '#ef4444';      // red
                    case 'valve': return '#8b5cf6';     // purple
                    case 'pipe': return '#6b7280';      // gray
                    default: return '#6b7280';          // gray
                }
            });

            console.log('Visualization colors reset to default');
        }

        // Show detailed node information
        function showNodeDetails(event, d) {
            let details = `Node Details:\n\nID: ${d.id}\nType: ${d.type}\nElevation: ${d.elevation?.toFixed(2) || 'N/A'} m\nBase Demand: ${d.base_demand?.toFixed(3) || 'N/A'} L/s\nTotal Head: ${d.head?.toFixed(2) || 'N/A'} m`;

            // Add time-related data
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    const pressure = getNodeValue(d.id, timeData.node_pressure);
                    const demand = getNodeValue(d.id, timeData.node_demand);

                    details += `\n\n=== Time ${currentTimeStep.toFixed(1)} Hours ===`;
                    if (pressure !== undefined) details += `\nPressure: ${pressure.toFixed(2)} m`;

                    // Calculate total head = pressure + elevation
                    if (pressure !== undefined && d.elevation !== undefined) {
                        const totalHead = pressure + d.elevation;
                        details += `\nTotal Head: ${totalHead.toFixed(2)} m`;
                    }

                    if (demand !== undefined) details += `\nActual Demand: ${demand.toFixed(3)} L/s`;

                    if (pressure === undefined && demand === undefined) {
                        details += `\n(No dynamic data for this time step)`;
                    }
                }
            }

            alert(details);
        }

        // Show detailed link information
        function showLinkDetails(event, d) {
            let details = `Link Details:\n\nID: ${d.id}\nType: ${d.type}\nStart Node: ${d.source.id || d.source}\nEnd Node: ${d.target.id || d.target}\nLength: ${d.length?.toFixed(2) || 'N/A'} m\nDiameter: ${d.diameter?.toFixed(0) || 'N/A'} mm\nRoughness: ${d.roughness || 'N/A'}`;

            // Add time-related data
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (csvData && dataSource && currentTimeStep !== null) {
                const timeData = getTimeData(currentTimeStep);
                if (timeData) {
                    const flow = getLinkValue(d.id, timeData.link_flow);
                    const velocity = getLinkValue(d.id, timeData.link_velocity);

                    details += `\n\n=== Time ${currentTimeStep.toFixed(1)} Hours ===`;
                    if (flow !== undefined) details += `\nFlow: ${flow.toFixed(4)} L/s`;
                    if (velocity !== undefined) details += `\nVelocity: ${velocity.toFixed(3)} m/s`;

                    if (flow === undefined && velocity === undefined) {
                        details += `\n(No dynamic data for this time step)`;
                    }
                }
            }

            alert(details);
        }

        // Update visualization data based on current time step
        function updateVisualizationData() {
            const dataSource = csvData?.csv_data?.data_by_time || csvData?.data_by_time;
            if (!csvData || !dataSource || !nodeElements || !linkElements) {
                console.log('Data visualization update failed: Missing required data', {
                    csvData: !!csvData,
                    data_by_time: !!dataSource,
                    nodeElements: !!nodeElements,
                    linkElements: !!linkElements
                });
                return;
            }

            // Use helper function to get time data
            const timeData = getTimeData(currentTimeStep);
            if (!timeData) {
                console.log('Time step data does not exist:', currentTimeStep, 'Available time steps:', Object.keys(dataSource));
                return;
            }

            console.log('Starting visualization data update:', {
                timeStep: currentTimeStep,
                nodePressureCount: Object.keys(timeData.node_pressure || {}).length,
                linkFlowCount: Object.keys(timeData.link_flow || {}).length
            });

            // Update node colors based on pressure
            nodeElements.style('fill', function (d) {
                // Try matching multiple ID formats
                let pressure = timeData.node_pressure[d.id];
                if (pressure === undefined) {
                    // Try adding .0 suffix
                    pressure = timeData.node_pressure[d.id + '.0'];
                }
                if (pressure === undefined) {
                    // Try removing .0 suffix
                    const idWithoutSuffix = d.id.replace('.0', '');
                    pressure = timeData.node_pressure[idWithoutSuffix];
                }

                if (pressure !== undefined) {
                    // Map pressure to color (Blue=Low, Red=High)
                    const normalizedPressure = Math.min(1, Math.max(0, pressure / 50)); // Adjust max pressure to 50m
                    const hue = (1 - normalizedPressure) * 240; // 240=Blue, 0=Red
                    return `hsl(${hue}, 70%, 50%)`;
                }
                // Keep original node type colors
                if (d.type === 'reservoir') return '#10b981';
                if (d.type === 'tank') return '#f59e0b';
                return '#3b82f6'; // Junction default blue
            });

            // Update link colors based on flow
            linkElements.style('stroke', function (d) {
                // Try matching multiple ID formats
                let flow = timeData.link_flow[d.id];
                if (flow === undefined) {
                    // Try adding .0 suffix
                    flow = timeData.link_flow[d.id + '.0'];
                }
                if (flow === undefined) {
                    // Try removing .0 suffix
                    const idWithoutSuffix = d.id.replace('.0', '');
                    flow = timeData.link_flow[idWithoutSuffix];
                }

                if (flow !== undefined) {
                    const absFlow = Math.abs(flow);
                    const normalizedFlow = Math.min(1, absFlow / 200); // Adjust max flow to 200 L/s
                    const intensity = Math.floor(normalizedFlow * 200 + 55); // Ensure color visibility
                    return flow >= 0 ? `rgb(0, ${intensity}, 0)` : `rgb(${intensity}, 0, 0)`;
                }
                // Keep original link type colors
                if (d.type === 'pump') return '#ef4444';
                if (d.type === 'valve') return '#8b5cf6';
                return '#6b7280'; // Pipe default gray
            });

            console.log('Visualization data update complete');
        }

        // Update node sizes
        function updateNodeSizes() {
            if (!nodeElements) return;

            nodeElements.attr('r', d => {
                const baseRadius = d.type === 'reservoir' ? 12 : d.type === 'tank' ? 10 : 6;
                return baseRadius * nodeSizeScale;
            });
        }

        // Update link sizes
        function updateLinkSizes() {
            if (!linkElements) return;

            linkElements.attr('stroke-width', function (d) {
                const baseWidth = d.type === 'pump' ? 4 : d.type === 'valve' ? 3 : Math.max(1, Math.min(8, (d.diameter || 100) / 50));
                return baseWidth * linkSizeScale;
            });
        }

        // Update node labels visibility
        function updateNodeLabelsVisibility() {
            if (!nodeLabels) return;
            nodeLabels.style('display', showNodeIds ? 'block' : 'none');
        }

        // Update link labels visibility
        function updateLinkLabelsVisibility() {
            if (!linkLabels) return;
            linkLabels.style('display', showLinkIds ? 'block' : 'none');
        }
    </script>

</html>